Prototype for Substrate client refactoring.

# Context

Like many big software projects, the Substrate client code has accumulated a lot of technical debt over time, mostly because of the many refactorings that it has gone through. Its overall complexity has been causing a lot of frustration and has slowed down development quite a lot.

In this context, `substrate-lite` has been started at the end of 2019 as a quick proof-of-concept of how to clarify and simplify the overall architecture of the Substrate client. Its scope has expanded over time, and during spring 2020 it became capable of syncing Kusama and Polkadot the same way a full node does.

More recently, mid-2020, the idea has emerged to use `substrate-lite` for the `substrate-connect` project, which consists in embedding a Substrate/Polkadot/Kusama light client inside of a browser. While `substrate-lite` is still far from being a fully-capable full node, it already supports all the features necessary for a light client to function.

In order to achieve simplicity, a few opinionated design choices have been made:

- No native runtime. The execution time of `wasmtime` is satisfying enough that having a native runtime isn't critical anymore. Relying only on the on-chain Wasm code considerably simplifies the code.
- No pluggable architecture. At the moment substrate-lite assumes that chains use Babe and GrandPa, which is the case of Westend, Kusama and Polkadot. Implementing other consensus algorithm (notably Aura and Sassafras) is not excluded, but their support would then be directly implemented in the main tree of substrate-lite. Support for plugging in "custom" consensus algorithms requires a considerably more complex code architecture, and is therefore out of scope.

## Why is this repository not public?

Two concerns should be resolved before making this repository public:

- We don't want external people to believe that this is going to replace Substrate or Polkadot.
- It is unclear whether this repository should be under GPL or Apache license. At the moment, all newly-written code is under Apache, but some code has been copy-pasted from Substrate and is still using the GPL.

# Status

As a quick overview, at the time of writing of this README, the following is supported:

- Verifying Babe blocks.
- "Executing" blocks, by calling `Core_execute_block`.
- Verifying GrandPa justifications.
- "Optimistic syncing", in other words syncing by assuming that there isn't any fork.
- Verifying storage trie proofs.
- The WebSocket JSON-RPC server is in progress, but its design is still changing.
- An informant.
- A telemetry client (mostly copy-pasted from Substrate and substrate-telemetry).

The networking has been copy-pasted from Substrate.

The following isn't done yet:

- Authoring blocks isn't supported.
- There is no transaction pool.
- Anything related to GrandPa networking messages. Finality can only be determined by asking a full node for a justification.
- No actual database for the full client.
- The changes trie isn't implemented (it is not enabled on Westend, Kusama and Polkadot at the moment).
- Prometheus metrics. While not difficult to implement, it seems a bit overkill to have one at the moment.

## How to test

There exists two clients.

The full client can be tested with `cargo run`.

> Note: The `Cargo.toml` contains a section `[profile.dev] opt-level = 2`, and as such `cargo run` alone should give performances close to the ones in release mode.

The light client running in a browser can be tested with `cd browser-node` and `./build.sh`.

# Objectives compared to Substrate

This code base proposed an opinionated approaches that differ from Substrate.

## Readability

The number one objective of this code base is to conform to the Substrate/Polkadot specs and not have any bug or security issue.

Beyond that, the most important metric of quality of this source code is how easy it is to understand.

The reference point of this metric is the documentation generated by `cargo doc`. It can more or less be seen as cargo-doc-driven development.

In details:

- Code must be properly documented, and the context for why the code exists should be given.
- Examples must be written as much as possible.
- When possible, use types found in the standard library rather than types defined locally or defined in other libraries. For example, always use `[u8; 32]` rather than `H256`.
- Trait definitions are only ever allowed for implementation details. Custom traits **must not** be exposed in any public API.

## Purity

When applicable, code must not have any side effect and must only ever return an output that directly depends on its inputs.

In particular, it must (when applicable) not perform any operation that directly or indirectly requires help from the operating system, such as getting the current time, accessing files, or sleeping the thread.

In details:

- No global variables (except for niche optimizations).
- No thread-local variables (except for niche optimizations).
- Never sleep the current thread. Everything must be asynchronous.
- No logging (no `log` library).

One must strive to make the code compile for `no_std` contexts if theoretically possible. As such, any code that directly or indirectly requires help from the operating system must be optional and disableable at compile-time.

## Reusability: don't mix concerns

Substrate is based on an architecture where each piece of code plays a specific role in a grander vision. The author of substrate-lite considers that this grander vision is too complicated for this kind of architecture.

In substrate-lite, however, almost all the modules of the source code are provided as tools, as if they were small libraries that are available to be used.

For example, features such as Prometheus metrics or the RPC endpoints **must not** be rooted in the code. It **must** be theoretically easy to remove support for this kind of feature from the source code. Prefer *pulling* information from components from a higher-level rather than passing `Arc` objects around.

Other example: the module that verifies whether a block respects the Babe algorithm must be passed as input the information required for this verification, and doesn't try, for example, to load the information from a database. The Babe verification code should only not be concerned with the concept of a database.

While the guidelines here a blurry, here are a few points:

- Dependency injection is almost always a bad thing. As such, any complex trait definition ("complex" here meaning "more complex than the ones found in the standard library such as `Clone` or `Eq`") is forbidden.
- Exposing `Arc`s in your public API is almost always a bad thing.

## Assumption that specs will not change

Substrate is organized around core components that are almost impossible to extract: a database, a client, the networking, a transaction pool, and so on. These components are tightly coupled together.

The blockchain-related logic is plugged on top of these core components and can, however, be changed. One can, for example, remove everything related to the Babe consensus algorithm and replace with by another consensus algorithm.

This project, on the other hand, is implemented following the current state of the Substrate/Polkadot specifications, and assumes that these specifications will never change. This assumption allows, in turn, for better readability and more flexibility when it comes to the purely engineering aspects of the codebase.

For example, the code that decodes block headers in written in a way that would be quite annoying (though straight-forward) to modify if the format of a block header ever changes. However, we simply assume that the format of block headers will rarely, if ever, change.

In particular, there is an assumption that the list of consensus algorithms is known in advance and will rarely change. Substrate-lite prefers the explicitness of code specific to every single consensus code, rather than giving the fake impression to the user that they can simply plug their own algorithm and expect everything to work.

## Fail fast

Code **must not** panic as a result of unexpected input from the user or from the network.

However, code **must** panic if its internal consistency is compromised. In other words, if the only possible reason for the panic is a bug in the logic of the code.

The author of this crate considers that it is dangerous to try to continue running the program if it is known that it does not run according to expectations.

While there is no rule in this source code about `unwrap`, the programmer is expected to think about every single `unwrap()` that they write and is concious that a `None` or an `Err` cannot happen unless a bug is present.

# Guidelines

Guidelines for writing code:

- The main objective is simplicity. The definition of simplicity is not how easy the code is to read, but how easy it is to understand. Verbose code can be just as simple to understand as concise code, sometimes more simple. As an example, introducing a procedural macro will often make the code nicer to read while greatly hurting understandability.
- No trait definitions, except for private traits used purely as implementation detail.
- No `Arc`s or `Mutex`es exposed in public APIs.
- No splitting of the crate into multiple crates without a good reason. "Improving compilation time" is not considered a good reason.
- No using the `log`, `tracing`, `slog`, etc. libraries, or any library whose use must be spread through the code base. As an example, `prometheus` is allowed but only in a well-scoped context and by pulling information from the various components, rather than injecting itself.
- Do not expose types of third-party libraries in the public API, unless there is a good reason to.
- Do not perform memory allocations unless the logic of the code you're writing requires storing data for later or passing data between tasks/threads. Memory allocations aren't a bad thing, but we should try to fight against the lazy habit of adding a `.to_vec()` or `.clone()` here and there to make the code compile and without thinking about it. Adding `to_vec()` or `clone()` is often the wrong solution to the problem.
- Embrace TODO-driven development. Try as much as possible to write code that will never need to change, but if that isn't possible leave a `// TODO` comment in the code explaining which modifications will be needed in the future. Writing code that will never need to change is still the preferred approach, and it's better to take more time before merging something than merging it with active TODOs.
  - Don't add TODOs for missing features, though, but only for known issues with the code.
- Do not try too hard to apply the "Don't Repeat Yourself" principle. Remember that the main objective is simplicity, and having to jump to a different file to understand what is going on is a big hit to this objective. Furthermore, two very similar pieces of code will often differ by their objective, in which case they should be in no way de-duplicated.
- Structs and functions are often private for a reason. Adding a `pub` where there isn't one is often a violation of encapsulation.
